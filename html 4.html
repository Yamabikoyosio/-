<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" id="u0" href="https://rakko.tools/tools/129/lib/tinymce/skins/ui/oxide/content.min.css"><link rel="stylesheet" type="text/css" id="u1" href="https://rakko.tools/tools/129/lib/tinymce/skins/content/default/content.min.css"></head><body id="tinymce" class="mce-content-body " data-id="content" contenteditable="true" spellcheck="false"><p>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;オセロ&lt;/title&gt;<br>&lt;style&gt;<br>table {<br>&nbsp; border-collapse: collapse;<br>}<br>td {<br>&nbsp; width: 50px;<br>&nbsp; height: 50px;<br>&nbsp; border: 1px solid black;<br>&nbsp; text-align: center;<br>&nbsp; font-size: 20px;<br>&nbsp; cursor: pointer;<br>}<br>.black {<br>&nbsp; background-color: black;<br>&nbsp; border-radius: 50%;<br>&nbsp; width: 80%;<br>&nbsp; height: 80%;<br>&nbsp; margin: 10%;<br>}<br>.white {<br>&nbsp; background-color: white;<br>&nbsp; border-radius: 50%;<br>&nbsp; width: 80%;<br>&nbsp; height: 80%;<br>&nbsp; margin: 10%;<br>}<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;</p><p>&lt;h1&gt;オセロ&lt;/h1&gt;</p><p>&lt;table id="board"&gt;<br>&lt;/table&gt;</p><p>&lt;script&gt;<br>const BOARD_SIZE = 8;<br>const board = document.getElementById('board');<br>let currentPlayer = 'black'; // 黒が先手<br>let gameOver = false;</p><p>// ボードの初期化<br>function initBoard() {<br>&nbsp; for (let i = 0; i &lt; BOARD_SIZE; i++) {<br>&nbsp; &nbsp; const row = board.insertRow();<br>&nbsp; &nbsp; for (let j = 0; j &lt; BOARD_SIZE; j++) {<br>&nbsp; &nbsp; &nbsp; const cell = row.insertCell();<br>&nbsp; &nbsp; &nbsp; cell.dataset.row = i;<br>&nbsp; &nbsp; &nbsp; cell.dataset.col = j;<br>&nbsp; &nbsp; &nbsp; cell.addEventListener('click', handleCellClick);<br>&nbsp; &nbsp; }<br>&nbsp; }</p><p>&nbsp; // 初期配置<br>&nbsp; setPiece(3, 3, 'white');<br>&nbsp; setPiece(4, 4, 'white');<br>&nbsp; setPiece(3, 4, 'black');<br>&nbsp; setPiece(4, 3, 'black');<br>}</p><p>// 石の配置<br>function setPiece(row, col, color) {<br>&nbsp; const cell = board.rows[row].cells[col];<br>&nbsp; const piece = document.createElement('div');<br>&nbsp; piece.classList.add(color);<br>&nbsp; cell.innerHTML = ''; // 子要素をクリア<br>&nbsp; cell.appendChild(piece);<br>}</p><p>// セルクリック時の処理<br>function handleCellClick(event) {<br>&nbsp; if (gameOver) return;</p><p>&nbsp; const cell = event.target;<br>&nbsp; const row = parseInt(cell.dataset.row);<br>&nbsp; const col = parseInt(cell.dataset.col);</p><p>&nbsp; // 石が置かれていないか確認<br>&nbsp; if (cell.firstChild) {<br>&nbsp; &nbsp; return;<br>&nbsp; }</p><p>&nbsp; // ひっくり返せる石があるか確認<br>&nbsp; if (canReverse(row, col, currentPlayer)) {<br>&nbsp; &nbsp; setPiece(row, col, currentPlayer);<br>&nbsp; &nbsp; reversePieces(row, col, currentPlayer);<br>&nbsp; &nbsp; switchPlayer();<br>&nbsp; &nbsp; checkGameOver();<br>&nbsp; }<br>}</p><p>// 石をひっくり返す<br>function reversePieces(row, col, color) {<br>&nbsp; const directions = [<br>&nbsp; &nbsp; [-1, -1], [-1, 0], [-1, 1],<br>&nbsp; &nbsp; [0, -1], &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0, 1],<br>&nbsp; &nbsp; [1, -1], &nbsp;[1, 0], &nbsp;[1, 1]<br>&nbsp; ];</p><p>&nbsp; for (const [dx, dy] of directions) {<br>&nbsp; &nbsp; let count = 0;<br>&nbsp; &nbsp; let r = row + dx;<br>&nbsp; &nbsp; let c = col + dy;<br>&nbsp; &nbsp; while (r &gt;= 0 &amp;&amp; r &lt; BOARD_SIZE &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; BOARD_SIZE) {<br>&nbsp; &nbsp; &nbsp; const targetCell = board.rows[r].cells[c];<br>&nbsp; &nbsp; &nbsp; if (!targetCell.firstChild) break;<br>&nbsp; &nbsp; &nbsp; if (targetCell.firstChild.classList.contains(color)) break;<br>&nbsp; &nbsp; &nbsp; count++;<br>&nbsp; &nbsp; &nbsp; r += dx;<br>&nbsp; &nbsp; &nbsp; c += dy;<br>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; if (count &gt; 0 &amp;&amp; r &gt;= 0 &amp;&amp; r &lt; BOARD_SIZE &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; BOARD_SIZE) {<br>&nbsp; &nbsp; &nbsp; const targetCell = board.rows[r].cells[c];<br>&nbsp; &nbsp; &nbsp; if (targetCell.firstChild &amp;&amp; targetCell.firstChild.classList.contains(color)) {<br>&nbsp; &nbsp; &nbsp; &nbsp; r = row + dx;<br>&nbsp; &nbsp; &nbsp; &nbsp; c = col + dy;<br>&nbsp; &nbsp; &nbsp; &nbsp; while (r !== row &amp;&amp; c !== col) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const cell = board.rows[r].cells[c];<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cell.firstChild.classList.toggle(color);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r += dx;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c += dy;<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>&nbsp; }<br>}</p><p>// 石をひっくり返せるか確認<br>function canReverse(row, col, color) {<br>&nbsp; const directions = [<br>&nbsp; &nbsp; [-1, -1], [-1, 0], [-1, 1],<br>&nbsp; &nbsp; [0, -1], &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0, 1],<br>&nbsp; &nbsp; [1, -1], &nbsp;[1, 0], &nbsp;[1, 1]<br>&nbsp; ];</p><p>&nbsp; for (const [dx, dy] of directions) {<br>&nbsp; &nbsp; let r = row + dx;<br>&nbsp; &nbsp; let c = col + dy;<br>&nbsp; &nbsp; while (r &gt;= 0 &amp;&amp; r &lt; BOARD_SIZE &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; BOARD_SIZE) {<br>&nbsp; &nbsp; &nbsp; const targetCell = board.rows[r].cells[c];<br>&nbsp; &nbsp; &nbsp; if (!targetCell.firstChild) break;<br>&nbsp; &nbsp; &nbsp; if (targetCell.firstChild.classList.contains(color)) break;<br>&nbsp; &nbsp; &nbsp; r += dx;<br>&nbsp; &nbsp; &nbsp; c += dy;<br>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; if (r &gt;= 0 &amp;&amp; r &lt; BOARD_SIZE &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; BOARD_SIZE) {<br>&nbsp; &nbsp; &nbsp; const targetCell = board.rows[r].cells[c];<br>&nbsp; &nbsp; &nbsp; if (targetCell.firstChild &amp;&amp; targetCell.firstChild.classList.contains(color)) {<br>&nbsp; &nbsp; &nbsp; &nbsp; return true;<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>&nbsp; }</p><p>&nbsp; return false;<br>}</p><p>// プレイヤー交代<br>function switchPlayer() {<br>&nbsp; currentPlayer = currentPlayer === 'black' ? 'white' : 'black';<br>&nbsp; if (!hasValidMove(currentPlayer)) {<br>&nbsp; &nbsp; // スキップ<br>&nbsp; &nbsp; currentPlayer = currentPlayer === 'black' ? 'white' : 'black';<br>&nbsp; &nbsp; if (!hasValidMove(currentPlayer)) {<br>&nbsp; &nbsp; &nbsp; // 両方とも置けない場合はゲーム終了<br>&nbsp; &nbsp; &nbsp; gameOver = true;<br>&nbsp; &nbsp; &nbsp; checkGameOver();<br>&nbsp; &nbsp; } else {<br>&nbsp; &nbsp; &nbsp; alert(currentPlayer + "は置ける場所がないためスキップします。");<br>&nbsp; &nbsp; }<br>&nbsp; }<br>}</p><p>// 有効な手があるか確認<br>function hasValidMove(color) {<br>&nbsp; for (let i = 0; i &lt; BOARD_SIZE; i++) {<br>&nbsp; &nbsp; for (let j = 0; j &lt; BOARD_SIZE; j++) {<br>&nbsp; &nbsp; &nbsp; if (!board.rows[i].cells[j].firstChild &amp;&amp; canReverse(i, j, color)) {<br>&nbsp; &nbsp; &nbsp; &nbsp; return true;<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>&nbsp; }<br>&nbsp; return false;<br>}</p><p>// 勝敗判定<br>function checkGameOver() {<br>&nbsp; let blackCount = 0;<br>&nbsp; let whiteCount = 0;<br>&nbsp; for (let i = 0; i &lt; BOARD_SIZE; i++) {<br>&nbsp; &nbsp; for (let j = 0; j &lt; BOARD_SIZE; j++) {<br>&nbsp; &nbsp; &nbsp; const cell = board.rows[i].cells[j];<br>&nbsp; &nbsp; &nbsp; if (cell.firstChild) {<br>&nbsp; &nbsp; &nbsp; &nbsp; if (cell.firstChild.classList.contains('black')) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blackCount++;<br>&nbsp; &nbsp; &nbsp; &nbsp; } else {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; whiteCount++;<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>&nbsp; }</p><p>&nbsp; if (blackCount + whiteCount === BOARD_SIZE * BOARD_SIZE || (!hasValidMove('black') &amp;&amp; !hasValidMove('white'))) {<br>&nbsp; &nbsp; gameOver = true;<br>&nbsp; &nbsp; let message = "";<br>&nbsp; &nbsp; if (blackCount &gt; whiteCount) {<br>&nbsp; &nbsp; &nbsp; message = "黒の勝ちです！";<br>&nbsp; &nbsp; } else if (whiteCount &gt; blackCount) {<br>&nbsp; &nbsp; &nbsp; message = "白の勝ちです！";<br>&nbsp; &nbsp; } else {<br>&nbsp; &nbsp; &nbsp; message = "引き分けです！";<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; alert(message);<br>&nbsp; }<br>}</p><p>initBoard();<br>&lt;/script&gt;</p><p>&lt;/body&gt;<br>&lt;/html&gt;</p></body></html>